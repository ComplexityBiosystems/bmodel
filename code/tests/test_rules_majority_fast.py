from bmodel.rules import majority_fast
from bmodel.generate import random_interaction_matrix

import pytest
import numpy as np
from itertools import product


@pytest.fixture
def neg_feedback():
    N = 2
    J = np.array([[0, -1], [-1, 0]])
    J_pseudo = np.identity(N) + 2 * J
    return N, J, J_pseudo


@pytest.fixture
def random_small():
    N = 10
    J = random_interaction_matrix(N=N)
    J_pseudo = np.identity(N) + 2 * J
    return N, J, J_pseudo


def test_majority_fast_correct_return_types(neg_feedback):
    """Check that the function returns what we expect"""
    N, J, J_pseudo = neg_feedback
    maxT = 100
    convergence, s, none1, none2, ic = majority_fast(
        N=N,
        J=J,
        J_pseudo=J_pseudo,
        maxT=maxT
    )
    assert isinstance(convergence, type(True))
    assert isinstance(s, np.ndarray)
    assert isinstance(none1, type(None))
    assert isinstance(none2, type(None))
    assert isinstance(ic, np.ndarray)


def test_majority_fast_correct_return_types_with_initial_conditions(neg_feedback):
    """
    Check that the function returns what we expect
    when we pass the initial conditions
    """
    N, J, J_pseudo = neg_feedback
    maxT = 100
    initial_condition = np.array([1., 1.])
    convergence, s, none1, none2, ic = majority_fast(
        N=N,
        J=J,
        J_pseudo=J_pseudo,
        maxT=maxT,
        initial_condition=initial_condition
    )
    assert isinstance(convergence, type(True))
    assert isinstance(s, np.ndarray)
    assert isinstance(none1, type(None))
    assert isinstance(none2, type(None))
    assert isinstance(ic, np.ndarray)


def test_majority_fast_correct_return_types_with_can_be_updated(neg_feedback):
    """
    Check that the function returns what we expect
    when we pass the set of nodes that can be updated
    """
    N, J, J_pseudo = neg_feedback
    maxT = 100
    can_be_updated = np.array([0])
    convergence, s, none1, none2, ic = majority_fast(
        N=N,
        J=J,
        J_pseudo=J_pseudo,
        maxT=maxT,
        can_be_updated=can_be_updated
    )
    assert isinstance(convergence, type(True))
    assert isinstance(s, np.ndarray)
    assert isinstance(none1, type(None))
    assert isinstance(none2, type(None))
    assert isinstance(ic, np.ndarray)


def test_majority_fast_correct_autogenerated_initial_conditions(random_small):
    """
    Check that when no initial condition is given, the one 
    autogenerated is a valid one, i.e. [-1, 1]^N
    """

    N, J, J_pseudo = random_small
    maxT = 100
    for _ in range(1000):
        _, _, _, _, ic = majority_fast(
            N=N,
            J=J,
            J_pseudo=J_pseudo,
            maxT=maxT,
        )
        assert isinstance(ic, np.ndarray)
        assert tuple(ic) in product([-1., 1.], repeat=N)


def test_majority_fast_steady_states_are_steady(random_small):
    """Check that steady states are really steady"""
    N, J, J_pseudo = random_small
    maxT = 10000
    for _ in range(1000):
        convergence, s, _, _, _ = majority_fast(
            N=N,
            J=J,
            J_pseudo=J_pseudo,
            maxT=maxT,
        )
        if convergence:
            assert np.all(np.sign(J_pseudo@s) == s)


def test_majority_fast_block_one_node(random_small):
    """Check that blocked nodes are not updated"""
    N, J, J_pseudo = random_small
    maxT = 10000
    for _ in range(100):
        initial_condition = np.random.randint(2, size=N)*2.-1.
        # block only one node
        for i in range(N):
            can_be_updated = np.concatenate(
                [np.arange(0, i), np.arange(i+1, N)])
            _, s, _, _, _ = majority_fast(
                N=N,
                J=J,
                J_pseudo=J_pseudo,
                maxT=maxT,
                initial_condition=initial_condition,
                can_be_updated=can_be_updated
            )
            assert s[i] == initial_condition[i]


def test_majority_fast_block_many_node(random_small):
    """Check that blocked nodes are not updated"""
    N, J, J_pseudo = random_small
    maxT = 10000
    for _ in range(1000):
        initial_condition = np.random.randint(2, size=N)*2.-1.
        # block some nodes at random
        can_be_updated = np.random.choice(
            range(N), size=int(N/2), replace=False)
        blocked = [x for x in range(N) if x not in can_be_updated]
        _, s, _, _, _ = majority_fast(
            N=N,
            J=J,
            J_pseudo=J_pseudo,
            maxT=maxT,
            initial_condition=initial_condition,
            can_be_updated=can_be_updated
        )
        for i in blocked:
            assert s[i] == initial_condition[i]
